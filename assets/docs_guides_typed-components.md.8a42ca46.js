import{_ as e,o,c as s,X as t}from"./chunks/framework.319defb2.js";const C=JSON.parse('{"title":"Typed Components","description":"Typed Components","frontmatter":{"description":"Typed Components"},"headers":[],"relativePath":"docs/guides/typed-components.md","filePath":"docs/guides/typed-components.md"}'),n={name:"docs/guides/typed-components.md"},p=t(`<h1 id="typed-components" tabindex="-1">Typed Components <a class="header-anchor" href="#typed-components" aria-label="Permalink to &quot;Typed Components&quot;">​</a></h1><p>使用 Stencil 生成的 Web 组件带有由 Stencil 编译器自动生成的类型声明文件。</p><p>一般来说，Typescript 声明在使用组件时提供了强大的保证:</p><ul><li>确保正确的值作为属性传递</li><li>现代 ide(如 VSCode)中的代码自动补全</li><li>事件明细</li><li>组件方法的签名</li></ul><p>这些公共类型是由 Stencil 在 <code>src/component.d.ts</code> 中自动生成的。 该文件允许在 JSX(就像 React)和每个组件的 <code>HTMLElement</code> 接口中使用强类型。</p><div class="info custom-block"><p class="custom-block-title">提示</p><p>建议将此文件与源代码控制中的其余代码一起检入。</p></div><p>因为 Stencil 生成的 Web 组件只是普通的 Web 组件，知识它们扩展了 <code>HTMLElement</code> 接口。 对于每个组件，在全局作用域中注册一个名为 <code>HTML{CamelCaseTag}Element</code> 的类型。 这意味着开发人员不必显式地导入它们，就像 <code>HTMLElement</code> 或 <code>HTMLScriptElement</code> 不会被导入一样。</p><ul><li><code>ion-button</code> =&gt; <code>HTMLIonButtonElement</code></li><li><code>ion-menu-controller</code> =&gt; <code>HTMLIonMenuControllerElement</code></li></ul><div class="language-tsx"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> button</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">HTMLIonButtonElement</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">queryElement</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">ion-button</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">button</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">fill </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">outline</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p><strong>重要提示</strong>：始终使用 <code>HTML{}Element</code> 接口来保存对组件的引用。</p><h2 id="properties" tabindex="-1">Properties <a class="header-anchor" href="#properties" aria-label="Permalink to &quot;Properties&quot;">​</a></h2><p>本节以经移动到 <a href="./../components/properties.html#types">Property Types</a></p><h3 id="required-properties" tabindex="-1">Required Properties <a class="header-anchor" href="#required-properties" aria-label="Permalink to &quot;Required Properties&quot;">​</a></h3><p>本节以经移动到 <a href="./../components/properties.html#required-properties">Required Properties</a></p>`,14),a=[p];function l(c,r,i,d,m,u){return o(),s("div",null,a)}const D=e(n,[["render",l]]);export{C as __pageData,D as default};
