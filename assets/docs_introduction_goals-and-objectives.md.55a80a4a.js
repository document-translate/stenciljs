import{_ as e,o as a,c as t,X as i}from"./chunks/framework.319defb2.js";const m=JSON.parse('{"title":"Stencil 的目标和目的","description":"Stencil旨在将最流行的前端框架的最佳概念结合到编译时工具中，而不是运行时工具。","frontmatter":{"description":"Stencil旨在将最流行的前端框架的最佳概念结合到编译时工具中，而不是运行时工具。"},"headers":[],"relativePath":"docs/introduction/goals-and-objectives.md","filePath":"docs/introduction/goals-and-objectives.md"}'),r={name:"docs/introduction/goals-and-objectives.md"},o=i('<h1 id="stencil-goals-and-objectives" tabindex="-1">Stencil 的目标和目的 <a class="header-anchor" href="#stencil-goals-and-objectives" aria-label="Permalink to &quot;Stencil 的目标和目的{#stencil-goals-and-objectives}&quot;">​</a></h1><p>Stencil 旨在将最流行的前端框架的最佳概念结合到编译时工具中，而不是运行时工具。 需要强调的是，Stencil 的目标不是成为或被视为一个“框架”，而是提供一个框架所期望的优秀开发人员体验和工具，同时在运行时在浏览器中使用 web 标准。 在许多情况下，考虑到浏览器中现有的功能，Stencil 可以作为传统前端框架的替代品，尽管这样使用它肯定不是必需的。</p><h2 id="web-standards" tabindex="-1">Web 标准 <a class="header-anchor" href="#web-standards" aria-label="Permalink to &quot;Web 标准{#web-standards}&quot;">​</a></h2><p>由 Stencil 生成的组件最终构建在 web 组件之上，因此它们可以在任何主要框架中工作，也可以在没有框架的情况下工作。 此外，其他标准严重依赖于 ES 模块和动态导入，它们已被证明可以取代传统的打包器，这些打包器会增加不必要的复杂性和运行时 JavaScript。 通过使用 web 标准，开发人员可以学习和采用世界各地的标准 API 文档，而不是不断变化的自定义框架 API。</p><h2 id="automatic-optimizations" tabindex="-1">自动优化 <a class="header-anchor" href="#automatic-optimizations" aria-label="Permalink to &quot;自动优化{#automatic-optimizations}&quot;">​</a></h2><p>开发人员必须做无数的优化和调整来提高组件和网站的性能。使用编译器，Stencil 能够分析组件代码作为输入，并生成优化的组件作为输出。</p><h2 id="future-friendly" tabindex="-1">未来友好 <a class="header-anchor" href="#future-friendly" aria-label="Permalink to &quot;未来友好{#future-friendly}&quot;">​</a></h2><p>随着软件开发的发展，编译器也在不断发展。编译器可以继续使用标准组件模型作为公共输入进行优化，而不需要完全重写组件。 编译器允许开发人员创建对未来友好的组件，同时仍然保持最新的优化，而无需一遍又一遍的开始。 此外，如果任何 API 发生了变化，编译器能够自动进行调整，并准确地通知开发人员需要更新什么。</p><h2 id="run-time-performance" tabindex="-1">运行时性能 <a class="header-anchor" href="#run-time-performance" aria-label="Permalink to &quot;运行时性能{#run-time-performance}&quot;">​</a></h2><p>与编写每个用户都需要下载和解析的自定义客户端 JavaScript 相比，Stencil 更喜欢使用直接构建在浏览器中的令人惊叹的 api。这些 api 包括自定义元素。</p><h2 id="tiny-api" tabindex="-1">微型 API <a class="header-anchor" href="#tiny-api" aria-label="Permalink to &quot;微型 API{#tiny-api}&quot;">​</a></h2><p>Stencil 故意不提供需要反复学习的大型自定义 API，而是严重依赖于，你猜对了，web 标准。 同样，我们的目标不是创建另一个框架，而是为开发人员提供工具，使用浏览器中已经烘焙好的 api 来生成对未来友好的组件。API 越小，越容易学习，容易出错。</p><h2 id="framework-features-during-development" tabindex="-1">开发过程中的框架特性 <a class="header-anchor" href="#framework-features-during-development" aria-label="Permalink to &quot;开发过程中的框架特性{#framework-features-during-development}&quot;">​</a></h2><p>如果你还没有注意到，我们认为 web 标准是伟大的，并提供了许多好处。 虽然在没有任何结构的情况下使用 web 标准当然是可能的，而且实际上在许多用例中这是合适的，但我们发现，随着应用程序和团队的扩展，它很快就变得难以管理。 开发人员经常被框架所吸引，因为它们有强大的工具、定义好的结构，以及允许开发人员快速构建应用程序的能力。 Stencil 最大的目标之一是在开发过程中拥有优秀的框架功能和一流的工具，但生成面向未来的 web 标准代码，而不是自定义的框架特定代码。</p><h2 id="wide-browser-support" tabindex="-1">广泛的浏览器支持 <a class="header-anchor" href="#wide-browser-support" aria-label="Permalink to &quot;广泛的浏览器支持{#wide-browser-support}&quot;">​</a></h2><p>对于少数不支持现代浏览器特性和 api 的浏览器，Stencil 会按需自动填充它们。 这意味着对于已经原生支持该特性的浏览器，它们将不需要下载和解析任何不必要的 JavaScript。 好消息是，在当今的 web 环境中，大多数现代 api 已经提供了 Stencil 所需的功能。</p>',16),n=[o];function c(s,l,d,p,h,u){return a(),t("div",null,n)}const f=e(r,[["render",c]]);export{m as __pageData,f as default};
